# Synthesis

## Synthesis Levels
- hight level synthesis
  - translation from **algorithmic behavior** description to **RTL** description
  - Input: HDL description code
  - Results: datapath(a network including registers, function units, multiplexer, bus for data transferring), controller(including  hardwired logic or firmware for controlling  the data transferring  in datapath )
- logic synthesis
  -  Translation from **RTL** description  to **logic gate netlist** (automatic process).
  - Translation from abstract description  to detailed description. 
- layout synthesis


# VHDL Synthesis
## Common features:
### 1) Supported subset
Supported types: `enumeration` , `integer`, `bit`, `std_logic`, `1darray`  
Partially supported types: `float`, `record`,`2darray`

### 2) Unsupported subset
Types without corresponding hardware can’t be synthesized, e.g. FILE.
Type :Time (after/wait for statement)

### 3）Rules for process description
 It’s more free to write a process for simulation,  but **for synthesis, a process includes at most one clock signal**. Some synthesis tools has further limitations on process description.

### 4）Synchronous design are preferred.
Synchronous description style is recommended by most of existing EDA tools, the circuit states change according to the clock rhythm.

For asynchronous design,  synthesis results usually need to be optimized by designer.  

## synthesizable data types
- a) bit ,  boolean , bit_vector
- b) character , string
- c) integer
- d) std_ulogic, std_ulogic_vector, std_logic , std_logic_vector      
- e) signed , unsigned


### Enumeration type
- For more abstract boolean and state_type, state encoding is necessary.(给enum里面的元素用二进制编号)

### Integer
- synthesizable integer should **have a range specification**

### Array
- 1darray is usually synthesized as bus
- 2darray can be synthesize into RAM

### Record(not supported by all tools)
- Difference between array and record: 
  - Array:  all elements should be of the same type.
  - Record: elements can be of different types

## Synthesizable data objects
- Constant
- Variable
- Signal
- ~~File~~

Variable and signal has different behaviors in simulation, and they produce different results in synthesis.**(P194-195,注意生成寄存器的数目)**

 1）Generally，better synthesis results can be obtained by making good use of variable.  Because synthesis optimization can be more flexible by using variable . But not all synthesizer support variable synthesis
        
  2）By using signal in process, good consistency can be achieved in signal I/O. It is usually necessary to use a signal if an intermediate data should be hold.

### 初值
三种赋初值的方式，见**P195**，建议使用第三种，即在process内部一开始就赋初值

## Synthesizable operator
### Logic operator
包括二元逻辑运算符如`and``or`等以及`not`操作，这些在综合的时候直接调用逻辑门单元实现，但不排除在优化时会被改动

### Relational Operator
没有统一的综合方式，但可以综合

### Unary arithmetic operator (一元算术运算符)
`+` `-` 可以被综合，但是`abs`不可以

### Binary arithmetic operator (二元算术运算符)
通常支持`加减乘`操作，部分支持`除`，取模运算一般不被支持

## Synthesizable Statements
### Sequential Statements
#### if statements
- if语句包含所有可能性，此时被综合为多路选择器
- 不完整if语句会产生寄存器。如果if语句判断条件为检测某一信号的跳变，则一般综合成FF。

#### case statements
- 不平衡的case语句可能也会产生寄存器，所谓不平衡是指不同case里面的操作次数不同

#### loop statements
- In RTL synthesis, the maximum number of iterations should be a finite, known and static value.
- P200-201两个例子，注意第二个用了`next`使得循环能够有选择性地执行

### Concurrent statement
Synthesizable concurrent  statements include  process,  concurrent assignment, block statement, generate statement. 
